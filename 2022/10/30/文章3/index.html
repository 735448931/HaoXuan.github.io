<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript高级学习 | HaoXuan🥝XiaoFu</title><meta name="author" content="盖世英雄昊轩"><meta name="copyright" content="盖世英雄昊轩"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JavaScript高级学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级学习">
<meta property="og:url" content="http://haoxuan.info/2022/10/30/%E6%96%87%E7%AB%A03/index.html">
<meta property="og:site_name" content="HaoXuan🥝XiaoFu">
<meta property="og:description" content="JavaScript高级学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://haoxuan.info/img/%E5%8E%9F%E7%A5%9E1%20(6).jpg">
<meta property="article:published_time" content="2022-10-29T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-15T12:53:43.203Z">
<meta property="article:author" content="盖世英雄昊轩">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://haoxuan.info/img/%E5%8E%9F%E7%A5%9E1%20(6).jpg"><link rel="shortcut icon" href="/img/pai.ico"><link rel="canonical" href="http://haoxuan.info/2022/10/30/%E6%96%87%E7%AB%A03/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript高级学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-15 20:53:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/fu/"><i class="fa-fw fas fa-thin fa-face-kiss-beam"></i><span> Fu</span></a></div><div class="menus_item"><a class="site-page" href="/aboutmy/"><i class="fa-fw fa-solid fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%8E%9F%E7%A5%9E1%20(6).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HaoXuan🥝XiaoFu</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/fu/"><i class="fa-fw fas fa-thin fa-face-kiss-beam"></i><span> Fu</span></a></div><div class="menus_item"><a class="site-page" href="/aboutmy/"><i class="fa-fw fa-solid fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript高级学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-29T16:00:00.000Z" title="发表于 2022-10-30 00:00:00">2022-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-15T12:53:43.203Z" title="更新于 2022-11-15 20:53:43">2022-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Javascript/">Javascript</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript-高级第一天"><a href="#JavaScript-高级第一天" class="headerlink" title="JavaScript 高级第一天"></a>JavaScript 高级第一天</h1><hr>
<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问</p>
<h3 id="1-1-局部作用域"><a href="#1-1-局部作用域" class="headerlink" title="1.1 局部作用域"></a>1.1 局部作用域</h3><p>局部作用域分为函数作用域和块作用域。</p>
<h4 id="1-1-1-函数作用域"><a href="#1-1-1-函数作用域" class="headerlink" title="1.1.1 函数作用域"></a>1.1.1 函数作用域</h4><p>特点：在函数内部声明的变量只能在函数内部被访问，外部无法直接访问</p>
<p>总结：</p>
<p>​	1.函数内部声明的变量，在函数外部无法被访问</p>
<p>​	2.函数的参数也是函数内部的局部变量</p>
<p>​	3.不同函数内部声明的变量无法互相访问</p>
<p>​	4.函数执行完毕后，函数内部的变量实际被清空了</p>
<h4 id="1-1-2-块作用域"><a href="#1-1-2-块作用域" class="headerlink" title="1.1.2 块作用域"></a>1.1.2 块作用域</h4><p>​	在 JavaScript 中使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问</p>
<p>​	JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。</p>
<p>总结：</p>
<p>​	1.let 声明的变量会产生块作用域，var 不会产生块作用域</p>
<p>​	2.const 声明的常量也会产生块作用域</p>
<p>​	3.不同代码块之间的变量无法互相访问</p>
<p>​	4.推荐使用 let 或 const</p>
<h3 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h3><p>​	script 标签 和 .js 文件 的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。</p>
<p>​	全局作用域中声明的变量，任何其它作用域都可以被访问</p>
<p>注意：</p>
<p>​	1.为 window 对象动态添加的属性默认也是全局的，不推荐！</p>
<p>​	2.函数中未使用任何关键字声明的变量为全局变量，不推荐！！！</p>
<p>​	3.尽可能少的声明全局变量，防止全局变量被污染</p>
<h3 id="1-3-作用域链"><a href="#1-3-作用域链" class="headerlink" title="1.3 作用域链"></a>1.3 作用域链</h3><p>作用域链本质上是底层的<strong>变量查找机制</strong>。 在函数被执行时，会优先查找当前函数作用域中查找变量如果当前作用域查找不到则会<strong>依次逐级查找父级作用域</strong>直到全局作用域</p>
<p>总结：</p>
<p>​	1.嵌套关系的作用域串联起来形成了作用域链</p>
<p>​	2.相同作用域链中按着从小到大的规则查找变量</p>
<p>​	3.子作用域能够访问父作用域，父级作用域无法访问子级作用域</p>
<h3 id="1-4-JS垃圾回收机制"><a href="#1-4-JS垃圾回收机制" class="headerlink" title="1.4 JS垃圾回收机制"></a>1.4 JS垃圾回收机制</h3><h4 id="1-4-1-垃圾回收机制-GC"><a href="#1-4-1-垃圾回收机制-GC" class="headerlink" title="1.4.1 垃圾回收机制 GC"></a>1.4.1 垃圾回收机制 GC</h4><p>​	JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p>
<p>​	不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong></p>
<h4 id="1-4-2-内存的生命周期"><a href="#1-4-2-内存的生命周期" class="headerlink" title="1.4.2 内存的生命周期"></a>1.4.2 内存的生命周期</h4><p>JS环境中分配的内存, 一般有如下生命周期：</p>
<p>​	1.内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</p>
<p>​	2.内存使用：即读写内存，也就是使用变量、函数等</p>
<p>​	3.内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</p>
<p>说明：	</p>
<p>​	全局变量一般不会回收(关闭页面回收)； </p>
<p>​	一般情况下局部变量的值, 不用了, 会被自动回收掉</p>
<h3 id="1-5-闭包"><a href="#1-5-闭包" class="headerlink" title="1.5 闭包"></a>1.5 闭包</h3><p>概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域</p>
<p>简单理解：闭包 &#x3D; 内层函数 + 外层函数的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>()</span><br></pre></td></tr></table></figure>

<p>闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 闭包的基本格式</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fn</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> fun = <span class="title function_">outer</span>() </span><br><span class="line">        <span class="title function_">fun</span>() <span class="comment">//  1</span></span><br><span class="line">        <span class="comment">// 外层函数使用内部函数的变量</span></span><br><span class="line">-----------</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//  outer()   ===  fn   ===  function fn() &#123;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> fun = <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123; &#125; = <span class="title function_">outer</span>()</span><br><span class="line">----------------</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(outer())</span></span><br><span class="line">    <span class="keyword">const</span> fun1 = <span class="title function_">outer</span>()</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun1</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的应用 </span></span><br><span class="line">   <span class="comment">// 普通形式 统计函数调用的次数</span></span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">     i++</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`函数被调用了<span class="subst">$&#123;i&#125;</span>次`</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  因为 i 是全局变量，容易被修改</span></span><br><span class="line">   <span class="comment">// 闭包形式 统计函数调用的次数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">       i++</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`函数被调用了<span class="subst">$&#123;i&#125;</span>次`</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> fn</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> fun = <span class="title function_">count</span>()</span><br></pre></td></tr></table></figure>

<p>闭包应用： <strong>实现数据的私有</strong></p>
<p>总结：</p>
<ol>
<li>闭包本质仍是函数，只不是从函数内部返回的</li>
<li>闭包能够创建外部可访问的隔离作用域，避免全局变量污染</li>
<li>过度使用闭包可能造成内存泄漏</li>
</ol>
<p>注：回调函数也能访问函数内部的局部变量。</p>
<h3 id="1-6-变量提升"><a href="#1-6-变量提升" class="headerlink" title="1.6 变量提升"></a>1.6 变量提升</h3><p>​	变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（<strong>仅存在于var声明变量</strong>）</p>
<p>注意：</p>
<p>​	1.变量在未声明即被访问时会报语法错误</p>
<p>​	2.变量在var声明之前即被访问，变量的值为 undefined</p>
<p>​	3.let&#x2F;const 声明的变量不存在变量提升，推荐使用let</p>
<p>​	4.变量提升出现在相同作用域当中</p>
<p>​	5.实际开发中推荐先声明再访问变量</p>
<p>变量提升的流程：</p>
<p>​	先把var 变量提升到当前作用域于最前面</p>
<p>​	<strong>只提升变量声明， 不提升变量赋值</strong></p>
<p>​	然后依次执行代码</p>
<h2 id="2-函数进阶"><a href="#2-函数进阶" class="headerlink" title="2.函数进阶"></a>2.函数进阶</h2><h3 id="2-1-函数提升"><a href="#2-1-函数提升" class="headerlink" title="2.1 函数提升"></a>2.1 函数提升</h3><p>​	函数提升与变量提升比较类似，是指函数在声明之前即可被调用</p>
<p>总结：</p>
<p>​	1.函数提升能够使函数的声明调用更灵活</p>
<p>​	2.函数表达式不存在提升的现象</p>
<p>​	3.函数提升出现在相同作用域当中</p>
<p>​	4.只提升函数声明，不提升函数调用</p>
<h3 id="2-2-函数参数"><a href="#2-2-函数参数" class="headerlink" title="2.2 函数参数"></a>2.2 函数参数</h3><p>总结：</p>
<ol>
<li>声明函数时为形参赋值即为参数的默认值</li>
<li>如果参数未自定义默认值时，参数的默认值为 <code>undefined</code></li>
<li>调用函数时没有传入对应实参时，参数的默认值被当做实参传入</li>
</ol>
<h4 id="2-2-1-动态参数"><a href="#2-2-1-动态参数" class="headerlink" title="2.2.1 动态参数"></a>2.2.1 动态参数</h4><p><strong>arguments</strong> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参</p>
<p>总结：</p>
<p>​	1.arguments 是一个<strong>伪数组</strong>，只存在于<strong>函数</strong>中</p>
<p>​	2.arguments 的作用是动态获取函数的实参</p>
<p>​	3.可以通过for循环依次得到传递过来的实参</p>
<p>使用场景：当不确定传递多少个实参的时候，我们使用 arguments 动态参数</p>
<h4 id="2-2-2-剩余参数-…"><a href="#2-2-2-剩余参数-…" class="headerlink" title="2.2.2 剩余参数 …"></a>2.2.2 剩余参数 <strong>…</strong></h4><p>​	剩余参数允许我们将一个不定数量的参数表示为一个数组</p>
<p>总结：</p>
<p>​	1. … 是语法符号，置于最末函数形参之前，用于获取多余的实参</p>
<p>​	2.借助 … 获取的剩余实参，是个   <code>   真数组</code></p>
<p>​	3.开发中，还是提倡多使用剩余参数</p>
<h4 id="2-2-3-展开运算符"><a href="#2-2-3-展开运算符" class="headerlink" title="2.2.3 展开运算符"></a>2.2.3 展开运算符</h4><p>展开运算符(…),将一个数组进行展开</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr) <span class="comment">// 1 5 3 8 2</span></span><br></pre></td></tr></table></figure>

<p>说明： 不会改变原数组</p>
<p>典型运用场景： 求数组最大值(最小值)、合并数组等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658406295170.png" alt="65840629517"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658406310159.png" alt="65840631015"></p>
<blockquote>
<p>展开运算符 or 剩余参数</p>
<p>​	剩余参数：函数参数使用，得到真数组</p>
<p>​	展开运算符：数组中使用，数组展开</p>
</blockquote>
<h3 id="2-3-箭头函数-重要"><a href="#2-3-箭头函数-重要" class="headerlink" title="2.3 箭头函数(重要)"></a>2.3 箭头函数(重要)</h3><p>箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。</p>
<h4 id="2-3-1-基本语法"><a href="#2-3-1-基本语法" class="headerlink" title="2.3.1 基本语法"></a>2.3.1 基本语法</h4><p>​	语法1：基本写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">   <span class="keyword">const</span> fu = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是普通函数&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn</span>()</span><br><span class="line">   <span class="comment">// 箭头函数</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是箭头函数&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn</span>()</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	语法2：只有一个参数可以省略小括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">       <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> x + x</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">1</span>)) <span class="comment">//  2</span></span><br><span class="line">       <span class="comment">// 箭头函数</span></span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> x + x </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">1</span>)) <span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p>​	语法3：如果函数体只有一行代码，可以写到一行上，并且无需写 return 直接返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//  3</span></span><br><span class="line">    <span class="comment">// 箭头函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>

<p>​	语法4： 加括号的函数体返回对象字面量表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = uname =&gt; (&#123; <span class="attr">uname</span>: uname &#125;)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn1</span>(<span class="string">&#x27;大帅哥&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>​	总结：</p>
<p>​		1.箭头函数属于表达式函数，因此不存在函数提升</p>
<p>​		2.箭头函数只有一个参数时可以省略圆括号 ()</p>
<p>​		3.箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回</p>
<p>​		4.加括号的函数体返回对象字面量表达式</p>
<h4 id="2-3-2-箭头函数参数"><a href="#2-3-2-箭头函数参数" class="headerlink" title="2.3.2 箭头函数参数"></a>2.3.2 箭头函数参数</h4><ul>
<li><p>普通函数有arguments动态参数</p>
</li>
<li><p>箭头函数没有arguments动态参数，但是有 剩余参数 …</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">...arr</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            sum += args[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="comment">// 注意函数体有多行代码需要return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//  6</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-箭头函数this"><a href="#2-3-3-箭头函数this" class="headerlink" title="2.3.3 箭头函数this"></a>2.3.3 箭头函数this</h4><p>​	在箭头函数出现之前，每一个新函数根据它是被<strong>如何调用的</strong>来定义这个函数的this值， 非常令人讨厌。</p>
<p>​	<strong>箭头函数不会创建自己的this</strong>,它只会从自己的作用域链的上一层沿用this。</p>
<p>​	在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此</p>
<p>​	<strong>DOM事件回调函数为了简便，还是不太推荐使用箭头函数</strong></p>
<h2 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h2><h3 id="3-1-数组解构"><a href="#3-1-数组解构" class="headerlink" title="3.1 数组解构"></a>3.1 数组解构</h3><p>解构赋值是一种<strong>快速为变量赋值的简洁语法</strong>，本质上仍然是为变量赋值。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658407583554.png" alt="65840758355"></p>
<p>小结： </p>
<p>​	1.赋值运算符 &#x3D; 左侧的[]用于批量声明变量，右侧数组的单元制将被赋值给左侧的变量</p>
<p>​	2.变量的顺序对应数组单元值的位置一次进行赋值操作</p>
<p>​	3.变量的数量大于单元值数量时，多余的变量将被赋值为 undefined</p>
<p>​	4.利用剩余参数解决变量少 单元值多的情况：剩余参数返回的还是一个数组</p>
<p>​	5.防止有undefined传递单元值的情况，可以设置默认值</p>
<p>​	6.支持多维数组的结构</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658408038508.png" alt="65840803850"></p>
</blockquote>
<h3 id="3-2-对象解构"><a href="#3-2-对象解构" class="headerlink" title="3.2 对象解构"></a>3.2 对象解构</h3><p>​	对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法</p>
<h4 id="3-2-1-基本语法"><a href="#3-2-1-基本语法" class="headerlink" title="3.2.1 基本语法"></a>3.2.1 基本语法</h4><p>​	1.赋值运算符 &#x3D; 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</p>
<p>​	2.对象属性的值将被赋值给与属性名相同的变量</p>
<p>​	3.注意解构的变量名不要和外面的变量名冲突否则报错</p>
<p>​	4.对象中找不到与变量名一致的属性时变量值为 undefined</p>
<h4 id="3-2-2-给新的变量名赋值"><a href="#3-2-2-给新的变量名赋值" class="headerlink" title="3.2.2 给新的变量名赋值"></a>3.2.2 给新的变量名赋值</h4><p>​	可以从一个对象中提取变量并同时修改新的变量名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658485840695.png" alt="65848584069"></p>
<h4 id="3-2-3-数组对象解构"><a href="#3-2-3-数组对象解构" class="headerlink" title="3.2.3 数组对象解构"></a>3.2.3 数组对象解构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658485869049.png" alt="65848586904"></p>
<h4 id="3-2-4-多级对象解构"><a href="#3-2-4-多级对象解构" class="headerlink" title="3.2.4 多级对象解构"></a>3.2.4 多级对象解构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658485928514.png" alt="65848592851"></p>
<h3 id="3-3-JS前面必须加分号情况"><a href="#3-3-JS前面必须加分号情况" class="headerlink" title="3.3 JS前面必须加分号情况"></a>3.3 JS前面必须加分号情况</h3><p>立即执行函数 和 数组解构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) ();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"> ;(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) ()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组开头的，特别是前面有语句的一定注意加分号</span></span><br><span class="line">;[b, a] = [a, b]</span><br></pre></td></tr></table></figure>

<h3 id="3-4-遍历数组-forEach-方法-重点"><a href="#3-4-遍历数组-forEach-方法-重点" class="headerlink" title="3.4 遍历数组 forEach 方法(重点)"></a>3.4 遍历数组 forEach 方法(重点)</h3><p>​	forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 </p>
<p>​	主要使用场景： 遍历数组的每个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法： 被遍历的数组.<span class="title function_">forEach</span>(<span class="params"><span class="keyword">function</span>(当前数组元素，当前元素索引号)</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数体</span></span><br><span class="line"></span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658488856120.png" alt="65848885612"></p>
<blockquote>
<p>1.forEach 主要是遍历数组</p>
<p>2.参数当前数组元素是必须要写的， 索引号可选。</p>
</blockquote>
<h5 id="案例练习-渲染商品列表案例"><a href="#案例练习-渲染商品列表案例" class="headerlink" title="案例练习-渲染商品列表案例"></a>案例练习-渲染商品列表案例</h5><p>核心思路：有多少条数据，就渲染多少模块，然后 生成对应的 html结构标签， 赋值给 list标签即可</p>
<p>​	①：利用forEach 遍历数据里面的 数据</p>
<p>​	②：拿到数据，利用字符串拼接生成结构添加到页面中</p>
<p>​	③：注意：传递参数的时候，可以使用对象解构</p>
<h2 id="4-综合案例-商品列表价格筛选"><a href="#4-综合案例-商品列表价格筛选" class="headerlink" title="4.综合案例-商品列表价格筛选"></a>4.综合案例-商品列表价格筛选</h2><p>需求：</p>
<p>①：渲染数据列表</p>
<p>②：根据选择不同条件显示不同商品</p>
<h3 id="4-1-筛选数组-filter-方法（重点）"><a href="#4-1-筛选数组-filter-方法（重点）" class="headerlink" title="4.1 筛选数组 filter 方法（重点）"></a>4.1 筛选数组 filter 方法（重点）</h3><p>​	filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</p>
<p>​	主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组</p>
<p>语法：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658489029211.png" alt="65848902921"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658489043308.png" alt="65848904330"></p>
<p>返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组</p>
<p>参数：currentValue 必须写， index 可选</p>
<p>因为返回新数组，所以不会影响原数组</p>
<hr>
<h1 id="JavaScript-高级第二天"><a href="#JavaScript-高级第二天" class="headerlink" title="JavaScript 高级第二天"></a>JavaScript 高级第二天</h1><hr>
<h2 id="1-深入对象"><a href="#1-深入对象" class="headerlink" title="1.深入对象"></a>1.深入对象</h2><h3 id="1-1-创建对象三种方法"><a href="#1-1-创建对象三种方法" class="headerlink" title="1.1 创建对象三种方法"></a>1.1 创建对象三种方法</h3><h4 id="1-1-1-利用对象字面量创建对象"><a href="#1-1-1-利用对象字面量创建对象" class="headerlink" title="1.1.1 利用对象字面量创建对象"></a>1.1.1 利用对象字面量创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-利用new-Object创建对象"><a href="#1-1-2-利用new-Object创建对象" class="headerlink" title="1.1.2 利用new Object创建对象"></a>1.1.2 利用new Object创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-利用构造函数创建对象"><a href="#1-1-3-利用构造函数创建对象" class="headerlink" title="1.1.3 利用构造函数创建对象"></a>1.1.3 利用构造函数创建对象</h4><h3 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h3><p>构造函数 ：是一种特殊的函数，<strong>主要用来初始化对象</strong>，如果一个函数使用 <code>new</code> 关键字调用，那么这个函数就是构造函数。</p>
<p>​	使用场景：常规的 {…} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一遍，此时可以通过构造函数来<strong>快速创建多个类似的对象</strong>。(构造函数在技术上是常规函数)</p>
<p>​	不过有两个约定：</p>
<p>​		1.它们的命名以<strong>大写字母开头</strong>。</p>
<p>​		2.它们只能由 “<strong>new</strong>“ 操作符来执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params">name,age,gender</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 创建对象</span></span><br><span class="line">       <span class="keyword">const</span> <span class="title class_">George</span> = <span class="keyword">new</span> <span class="title class_">Pig</span>(<span class="string">&#x27;乔治&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">       <span class="keyword">const</span> <span class="title class_">Mom</span> = <span class="keyword">new</span> <span class="title class_">Pig</span>(<span class="string">&#x27;猪妈妈&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>1.<strong>使用 new 关键字调用函数的行为被称为实例化</strong></p>
<p>2.实例化构造函数时没有参数时可以省略 () 不建议省略</p>
<p>3.构造函数内部无需写return，返回值即为新创建的对象</p>
<p>4.构造函数内部的 return 返回的值无效，所以不要写return</p>
<p>5.new Object（） new Date（） 也是实例化构造函数</p>
</blockquote>
<p><code>实例化的执行过程</code>：</p>
<p>​	1.创建新对象</p>
<p>​	2.构造函数this指向新对象</p>
<p>​	3.执行构造函数代码，修改this，添加新的属性</p>
<p>​	4.返回新对象</p>
<h3 id="1-3-实例成员-amp-静态成员"><a href="#1-3-实例成员-amp-静态成员" class="headerlink" title="1.3 实例成员&amp;静态成员"></a>1.3 实例成员&amp;静态成员</h3><p>实例成员：通过构造函数创建的对象称为实例对象，<strong>实例对象中的属性和方法称为实例成员。</strong></p>
<p>总结：</p>
<p>​	1.构造函数内部 <code>this</code> 实际上就是实例对象，为其动态添加的属性和方法即为实例成员</p>
<p>​	2.为构造函数传入参数，动态创建结构相同但值不同的对象</p>
<p>注：构造函数创建的实例对象彼此独立互不影响。</p>
<p>静态成员：<strong>构造函数的属性和方法被称为静态成员</strong></p>
<p>说明：</p>
<p>​	1.静态成员指的是添加到构造函数本身的属性和方法</p>
<p>​	2.一般公共特征的属性或方法静态成员设置为静态成员</p>
<p>​	3.静态成员方法中的 this 指向构造函数本身</p>
<h2 id="2-内置构造函数"><a href="#2-内置构造函数" class="headerlink" title="2.内置构造函数"></a>2.内置构造函数</h2><p>在 JavaScript 中<strong>最主要</strong>的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。</p>
<h3 id="2-1-Object"><a href="#2-1-Object" class="headerlink" title="2.1 Object"></a>2.1 Object</h3><p>​	Object 是内置的构造函数，用于创建普通对象</p>
<p>​	学习三个常用静态方法（静态方法就是只有构造函数Object可以调用的）</p>
<p>以前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(k) <span class="comment">// 属性 name age</span></span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]) <span class="comment">//  值 佩奇 6</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>现在：	Object.keys 静态方法获取对象中所有属性（键）</p>
<p>​		Object.values 静态方法获取对象中所有属性值</p>
<p>​		Object. assign 静态方法常用于对象拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> arr = <span class="title class_">Object</span>.<span class="title function_">key</span>(obj)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [&#x27;name&#x27;,&#x27;age&#x27;]</span></span><br><span class="line">注意 ： 返回的是一个数组</span><br><span class="line">----------------------------------------------</span><br><span class="line">	<span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> arr1 = <span class="title class_">Object</span>.<span class="title function_">values</span>(obj1)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [&#x27;佩奇&#x27;,6]</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">	<span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> obj3 = &#123;&#125;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj3,obj2)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj3) <span class="comment">// &#123;name:&#x27;佩奇&#x27;， age：6&#125;</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">使用： 经常使用的场景是给对象添加属性 例如：</span><br><span class="line">    <span class="keyword">const</span> o = &#123; <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(o, &#123; <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o)  </span><br></pre></td></tr></table></figure>

<h3 id="2-2-Array"><a href="#2-2-Array" class="headerlink" title="2.2 Array"></a>2.2 Array</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>遍历数组</td>
<td>不返回，用于不改变值，经常用于查找打印输出值</td>
</tr>
<tr>
<td>filter</td>
<td>过滤数组</td>
<td>筛选数组元素，并生成新数组</td>
</tr>
<tr>
<td>map</td>
<td>迭代数组</td>
<td>返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据</td>
</tr>
<tr>
<td>reduce</td>
<td>累计器</td>
<td>返回函数累计处理的结果，经常用于求和等</td>
</tr>
</tbody></table>
<p>​	基本语法： arr.reduce(function(){}, 起始值)</p>
<p>​	reduce参数：</p>
<p>1.如果有起始值，则以起始值为准开始累计， 累计值 &#x3D; 起始值</p>
<p>2.如果没有起始值， 则累计值以数组的第一个数组元素作为起始值开始累计</p>
<p>3.后面每次遍历就会用后面的数组元素 累计到 累计值 里面 （类似求和里面的 sum ）</p>
<p>​	使用场景：求和运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">        <span class="keyword">let</span> count = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">prev, item</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev + item</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line">------------------------------------------------------</span><br><span class="line">	 <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">        <span class="keyword">let</span> count = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> prev + item)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br></pre></td></tr></table></figure>

<h5 id="案例练习-员工涨薪计算成本"><a href="#案例练习-员工涨薪计算成本" class="headerlink" title="案例练习-员工涨薪计算成本"></a>案例练习-员工涨薪计算成本</h5><p>需求：</p>
<p>​	①：给员工每人涨薪 30%</p>
<p>​	②：然后计算需要支出的费用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658491502336.png" alt="65849150233"></p>
<p>总结：</p>
<ol>
<li>推荐使用字面量方式声明数组，而不是 <code>Array</code> 构造函数</li>
<li>实例方法 <code>forEach</code> 用于遍历数组，替代 <code>for</code> 循环 (重点)</li>
<li>实例方法 <code>filter</code> 过滤数组单元值，生成新数组(重点)</li>
<li>实例方法 <code>map</code> 迭代原数组，生成新数组(重点)</li>
<li>实例方法 <code>join</code> 数组元素拼接为字符串，返回字符串(重点)</li>
<li>实例方法  <code>find</code>  查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点)</li>
<li>实例方法<code>every</code> 检测数组所有元素是否都符合指定条件，如果<strong>所有元素</strong>都通过检测返回 true，否则返回 false(重点)</li>
<li>实例方法<code>some</code> 检测数组中的元素是否满足指定条件   <strong>如果数组中有</strong>元素满足条件返回 true，否则返回 false</li>
<li>实例方法 <code>concat</code>  合并两个数组，返回生成新数组</li>
<li>实例方法 <code>sort</code> 对原数组单元值排序</li>
<li>实例方法 <code>splice</code> 删除或替换原数组单元</li>
<li>实例方法 <code>reverse</code> 反转数组</li>
<li>实例方法 <code>findIndex</code>  查找元素的索引值</li>
</ol>
<h3 id="2-3-String"><a href="#2-3-String" class="headerlink" title="2.3 String"></a>2.3 String</h3><p>总结：</p>
<ol>
<li>实例属性 <code>length</code> 用来获取字符串的度长(重点)</li>
<li>实例方法 <code>split(&#39;分隔符&#39;)</code> 用来将字符串拆分成数组(重点)</li>
<li>实例方法 <code>substring（需要截取的第一个字符的索引[,结束的索引号]）</code> 用于字符串截取(重点)</li>
<li>实例方法 <code>startsWith(检测字符串[, 检测位置索引号])</code> 检测是否以某字符开头(重点)</li>
<li>实例方法 <code>includes(搜索的字符串[, 检测位置索引号])</code> 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点)</li>
<li>实例方法 <code>toUpperCase</code> 用于将字母转换成大写</li>
<li>实例方法 <code>toLowerCase</code> 用于将就转换成小写</li>
<li>实例方法 <code>indexOf</code>  检测是否包含某字符</li>
<li>实例方法 <code>endsWith</code> 检测是否以某字符结尾</li>
<li>实例方法 <code>replace</code> 用于替换字符串，支持正则匹配</li>
<li>实例方法 <code>match</code> 用于查找字符串，支持正则匹配</li>
</ol>
<p>注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。</p>
<h3 id="2-4-Number"><a href="#2-4-Number" class="headerlink" title="2.4 Number"></a>2.4 Number</h3><p>​	Number 是内置的构造函数，用于创建数值</p>
<p>​	常用方法：</p>
<p>​		toFixed() 设置保留小数位的长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> price = <span class="number">12.345</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(price.<span class="title function_">toFixed</span>(<span class="number">2</span>))  <span class="comment">//  12.35</span></span><br></pre></td></tr></table></figure>


<h1 id="JavaScript-高级第三天"><a href="#JavaScript-高级第三天" class="headerlink" title="JavaScript 高级第三天"></a>JavaScript 高级第三天</h1><h2 id="1-编程思想"><a href="#1-编程思想" class="headerlink" title="1.编程思想"></a>1.编程思想</h2><h3 id="1-1-面向过程编程"><a href="#1-1-面向过程编程" class="headerlink" title="1.1 面向过程编程"></a>1.1 面向过程编程</h3><p>​	面向过程，就是按照我们分析好了的步骤，按照步骤解决问题</p>
<h3 id="1-2-面向对象编程（oop）"><a href="#1-2-面向对象编程（oop）" class="headerlink" title="1.2 面向对象编程（oop）"></a>1.2 面向对象编程（oop）</h3><p>​	封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。</p>
<p>​	面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。 </p>
<p><strong>面向对象的特性：</strong> 封装性  继承性  多态性</p>
<p>总结 </p>
<p>​	面向过程编程 </p>
<p>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p>​	面向对象编程</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p>总结：</p>
<ol>
<li>构造函数体现了面向对象的封装特性</li>
<li>构造函数实例创建的对象彼此独立、互不影响</li>
<li>命名空间式的封装无法保证数据的独立性</li>
</ol>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><p>​	封装是面向对象思想中比较重要的一部分，js面向对象可以通过<strong>构造函数</strong>实现的封装。</p>
<p>​	前面我们学过的构造函数方法很好用，但是存在<strong>浪费内存</strong>的问题</p>
<h2 id="3-原型"><a href="#3-原型" class="headerlink" title="3.原型"></a>3.原型</h2><h3 id="3-1-原型"><a href="#3-1-原型" class="headerlink" title="3.1 原型"></a>3.1 原型</h3><p>构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。 </p>
<p>JavaScript 规定，<strong>每一个构造函数都有一个 prototype 属性</strong>，指向另一个对象，所以我们也称为原型对象</p>
<p>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</p>
<p><strong>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</strong> </p>
<p><strong>构造函数和原型对象中的this 都指向实例化的对象</strong></p>
<p> JavaScript 中对象的工作机制：<strong>当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。</strong></p>
<h3 id="3-2-constructor-属性"><a href="#3-2-constructor-属性" class="headerlink" title="3.2 constructor 属性"></a>3.2 constructor 属性</h3><p>每个原型对象里面都有个constructor 属性（constructor 构造函数）</p>
<p>作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子</p>
<p>使用场景：</p>
<p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.</p>
<p>但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了</p>
<p>此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>
<h3 id="3-3-对象原型"><a href="#3-3-对象原型" class="headerlink" title="3.3 对象原型"></a>3.3 对象原型</h3><p>对象都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype </p>
<p>原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658573058220.png" alt="65857305822"></p>
<p>注意：</p>
<p><strong>proto</strong> 是JS非标准属性</p>
<p>[[prototype]]和__proto__意义相同</p>
<p>用来表明当前实例对象指向哪个原型对象prototype</p>
<p>__proto__对象原型里面也有一个 constructor属性，<strong>指向创建该实例对象的构造函数</strong></p>
<h3 id="3-4-原型继承"><a href="#3-4-原型继承" class="headerlink" title="3.4 原型继承"></a>3.4 原型继承</h3><p>继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性</p>
<p>例子：</p>
<p>1.封装-抽取公共部分</p>
<p>把男人和女人公共的部分抽取出来放到人类里面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658573529677.png" alt="65857352967"></p>
<p>2.继承-让男人和女人都能继承人类的一些属性和方法</p>
<p>把男人女人公共的属性和方法抽取出来 People</p>
<p>然后赋值给Man的原型对象，可以共享这些属性和方法</p>
<p>注意让constructor指回Man这个构造函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658573560937.png" alt="65857356093"></p>
<p>3.问题：–原因</p>
<p>男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响</p>
<p>4.解决：</p>
<p>需求：男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法</p>
<p>答案：构造函数</p>
<p>new 每次都会创建一个新的对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658659288358.png" alt="65865928835"></p>
<h3 id="3-5-原型链"><a href="#3-5-原型链" class="headerlink" title="3.5 原型链"></a>3.5 原型链</h3><p>​	基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对</p>
<p>象的链状结构关系称为原型链</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/1658659316508.png" alt="65865931650"></p>
<p>查找规则：</p>
<p>​	① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</p>
<p>​	② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象） </p>
<p>​	③ 如果还没有就查找原型对象的原型（Object的原型对象） </p>
<p>​	④ 依此类推一直找到 Object 为止（null） </p>
<p>​	⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p>
<p>​	⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>
<h2 id="4-综合案例–消息提示对象封装"><a href="#4-综合案例–消息提示对象封装" class="headerlink" title="4.综合案例–消息提示对象封装"></a>4.综合案例–消息提示对象封装</h2><p>目的： 练习面向对象写插件（模态框）</p>
<p>分析需求：</p>
<p>1.定义模态框 Modal 构造函数，用来创建对象</p>
<p>2.模态框具备 打开功能 open 方法 （按钮点击可以打开模态框）</p>
<p>3.模态框 具备关闭功能 close 方法</p>
<p>问：</p>
<p>open 和 close 方法 写到哪里？</p>
<p>构造函数的原型对象上，共享方法</p>
<p>所以可以分为三个模块， 构造函数， open方法， close方法</p>
<p>步骤：</p>
<p>①：Modal 构造函数 制作</p>
<p>- 需要的公共属性： 标题（title）、提示信息内容（message） 可以设置默认参数</p>
<p>- 在页面中创建模态框</p>
<p>(1) 创建div标签可以命名为：modalBox</p>
<p>(2) div标签的类名为 modal </p>
<p>(3) 标签内部添加 基本结构，并填入相关数据</p>
<p>①：open方法</p>
<p>- 写到构造函数的原型对象身上</p>
<p>- 把刚才创建的modalBox 添加到 页面 body 标签中</p>
<p>- open 打开的本质就是 把创建标签添加到页面中</p>
<p>- 点击按钮， 实例化对象，传入对应的参数，并执行 open 方法</p>
<p>①：close方法</p>
<p>- 写到构造函数的原型对象身上</p>
<p>- 把刚才创建的modalBox 从页面 body 标签中 删除</p>
<p>- 需要注意，x 删除按钮绑定事件，要写到open里面添加</p>
<p>因为open是往页面中添加元素，同时顺便绑定事件</p>
<hr>
<h1 id="JavaScript-高级第四天"><a href="#JavaScript-高级第四天" class="headerlink" title="JavaScript 高级第四天"></a>JavaScript 高级第四天</h1><h2 id="1-深浅拷贝"><a href="#1-深浅拷贝" class="headerlink" title="1.深浅拷贝"></a>1.深浅拷贝</h2><p>​	首先浅拷贝和深拷贝只针对想Object,Array这样的复杂对象，简单来说，浅拷贝只复制一层对象的属性，二深拷贝则复制了所有的层级。</p>
<p>​	对于字符串类型，浅复制是对值的复制，对于对象来说，浅复制是对对象地址的复制，并没   有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会 改变，而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p>
<h3 id="1-1-浅拷贝"><a href="#1-1-浅拷贝" class="headerlink" title="1.1 浅拷贝"></a>1.1 浅拷贝</h3><p>浅拷贝拷贝的是地址</p>
<p>常见方法：如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)</p>
<p>​	1.拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</p>
<p>​	2.拷贝数组：Array.prototype.concat() 或者 […arr]</p>
<h3 id="1-2-深拷贝"><a href="#1-2-深拷贝" class="headerlink" title="1.2 深拷贝"></a>1.2 深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p>
<p>常用方法：</p>
<p>​	1.通过递归实现深拷贝</p>
<p>​		函数递归：</p>
<p>​		如果一个函数在内部可以调用其本身，那么这个函数就是递归函数</p>
<p>​		简单理解:函数内部自己调用自己, 这个函数就是递归函数</p>
<p>​		递归函数的作用和循环效果类似</p>
<p>​		由于递归很容易发生“栈溢出”错误（stack overflow），<strong>所以必须要加退出条件 return</strong></p>
<p>​	2.lodash&#x2F;cloneDeep</p>
<p>​	3.通过JSON.stringify()实现</p>
<h2 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2.异常处理"></a>2.异常处理</h2><h3 id="2-1-throw-抛异常"><a href="#2-1-throw-抛异常" class="headerlink" title="2.1 throw 抛异常"></a>2.1 throw 抛异常</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p>
<p>总结：</p>
<p>​	1.throw 抛出异常信息，<strong>程序也会终止执行</strong></p>
<p>​	2.throw 后面跟的是错误提示信息</p>
<p>​	3.<strong>Error 对象配合 throw 使用</strong>，能够设置更详细的错误信息</p>
<h3 id="2-2-try-x2F-catch-捕获异常"><a href="#2-2-try-x2F-catch-捕获异常" class="headerlink" title="2.2 try &#x2F; catch 捕获异常"></a>2.2 try &#x2F; catch 捕获异常</h3><p>我们可以通过try &#x2F; catch 捕获错误信息（浏览器提供的错误信息） try 试试 catch 拦住 finally 最后</p>
<p>总结：</p>
<p>​	1.try…catch 用于捕获错误信息</p>
<p>​	2.将预估可能发生错误的代码写在 try 代码段中</p>
<p>​	3.如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息</p>
<p>​	4.finally 不管是否有错误，都会执行</p>
<h3 id="2-3-debugger"><a href="#2-3-debugger" class="headerlink" title="2.3 debugger"></a>2.3 debugger</h3><p>打断点</p>
<h2 id="3-处理this"><a href="#3-处理this" class="headerlink" title="3.处理this"></a>3.处理this</h2><h3 id="3-1-this-指向"><a href="#3-1-this-指向" class="headerlink" title="3.1 this 指向"></a>3.1 this 指向</h3><h4 id="3-1-1-普通函数this指向"><a href="#3-1-1-普通函数this指向" class="headerlink" title="3.1.1 普通函数this指向"></a>3.1.1 普通函数this指向</h4><p>普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】</p>
<p>普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined </p>
<h4 id="3-1-2-箭头函数this指向"><a href="#3-1-2-箭头函数this指向" class="headerlink" title="3.1.2 箭头函数this指向"></a>3.1.2 箭头函数this指向</h4><p>箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上<strong>箭头函数中并不存在 this ！</strong></p>
<p>1.箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的</p>
<p>2.箭头函数中的this引用的就是最近作用域中的this</p>
<p>3.向外层作用域中，一层一层查找this，直到有this的定义</p>
<p>注意情况1： </p>
<p>在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window</p>
<p>因此DOM事件回调函数如果里面需要DOM对象的this，则不推荐使用箭头函数</p>
<p>注意情况2：</p>
<p>同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数</p>
<p>总结：</p>
<p>​	1.函数内不存在this，沿用上一级的</p>
<p>​	2.不适用</p>
<p>​		构造函数，原型函数，dom事件函数等等</p>
<p>​	3.适用</p>
<p>​		需要使用上层this的地方</p>
<p>​	4.使用正确的话，它会在很多地方带来方便，后面我们会大量使用慢慢体会</p>
<h3 id="3-2-改变-this"><a href="#3-2-改变-this" class="headerlink" title="3.2 改变 this"></a>3.2 改变 this</h3><h4 id="3-2-1-call"><a href="#3-2-1-call" class="headerlink" title="3.2.1 call()"></a>3.2.1 call()</h4><p>使用 call 方法调用函数，同时指定被调用函数中 this 的值 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="keyword">let</span> obj = &#123;</span><br><span class="line">           <span class="attr">name</span>: <span class="string">&#x27;小付&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 指向obj</span></span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);  <span class="comment">// 传递过来的参数相加</span></span><br><span class="line">       &#125;</span><br><span class="line">       fn.<span class="title function_">call</span>(obj, x, y)</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-apply"><a href="#3-2-2-apply" class="headerlink" title="3.2.2 apply()"></a>3.2.2 apply()</h4><p>使用 apply 方法调用函数，同时指定被调用函数中 this 的值 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//    求和函数</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 counter 函数，并传入参数</span></span><br><span class="line">        <span class="keyword">let</span> result = counter.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>
<li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>
<li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li>
</ol>
<h4 id="3-2-3-bind"><a href="#3-2-3-bind" class="headerlink" title="3.2.3 bind()"></a>3.2.3 bind()</h4><p>bind() 方法不会调用函数。但是能改变函数内部 this 指向</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> user = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;小付&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 bind 指定 this 的值</span></span><br><span class="line">        <span class="keyword">let</span> sayHello = sayHi.<span class="title function_">bind</span>(user)</span><br><span class="line">        <span class="comment">// 调用使用 bind 创建的新函数</span></span><br><span class="line">        <span class="title function_">sayHello</span>()</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>call apply bind  总结：</p>
<p>相同点: </p>
<p>​	都可以改变函数内部的this指向. </p>
<p>区别点: </p>
<p>​	call 和 apply 会调用函数, 并且改变函数内部this指向. </p>
<p>​	call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg] </p>
<p>​	bind 不会调用函数, 可以改变函数内部this指向. </p>
<p>主要应用场景: </p>
<p>​	call 调用函数并且可以传递参数</p>
<p>​	apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</p>
<p>​	bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向</p>
<h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4.性能优化"></a>4.性能优化</h2><p>节流：两个时间相减，如果大于等于默认的时间，之后再调用函数</p>
<p>防抖：触发事件的时候，不断清除定时器，当事件不再执行多少毫秒之后，开启定时器</p>
<h4 id="4-1-防抖"><a href="#4-1-防抖" class="headerlink" title="4.1 防抖"></a>4.1 防抖</h4><p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</p>
<p>开发使用场景- 搜索框防抖</p>
<p>假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多</p>
<p>我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，</p>
<p>则需要再等300ms 后发送请求</p>
<h4 id="4-2-节流"><a href="#4-2-节流" class="headerlink" title="4.2 节流"></a>4.2 节流</h4><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</p>
<p>开发使用场景 – 小米轮播图点击效果 、 鼠标移动、页面尺寸缩放resize、滚动条滚动 就可以加节流</p>
<h4 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h4><p>1.节流和防抖的区别是？</p>
<p>​	节流: 就是指连续触发事件但是在 n 秒中只执行一次函数,比如</p>
<p>可以利用节流实现 1s之内 只能触发一次鼠标移动事件</p>
<p>​	防抖：如果在 n 秒内又触发了事件，则会重新计算函数执行时</p>
<p>间</p>
<p>2.节流和防抖的使用场景是？ </p>
<p>​	节流: 鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较</p>
<p>大的情况下</p>
<p>​	防抖: 搜索框输入，设定每次输入完毕n秒后发送请求，如果期</p>
<p>间还有输入，则从新计算时间</p>
<h2 id="5-综合案例-页面打开，可以记录上一次的视频播放位置"><a href="#5-综合案例-页面打开，可以记录上一次的视频播放位置" class="headerlink" title="5.综合案例-页面打开，可以记录上一次的视频播放位置"></a>5.综合案例-页面打开，可以记录上一次的视频播放位置</h2><p>分析：</p>
<p>两个事件:</p>
<p>①：ontimeupdate 事件在视频&#x2F;音频（audio&#x2F;video）当前的播放位置发送改变时触发</p>
<p>②：onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频&#x2F;音频（audio&#x2F;video）的</p>
<p>下一帧时触发</p>
<p>谁需要节流？</p>
<p>ontimeupdate ， 触发频次太高了，我们可以设定 1秒钟触发一次</p>
<p>思路：</p>
<p>1.在ontimeupdate事件触发的时候，每隔1秒钟，就记录当前时间到本地存储</p>
<p>2.下次打开页面， onloadeddata 事件触发，就可以从本地存储取出时间，让视频从取出的时间播放，如</p>
<p>果没有就默认为0s</p>
<p>3.获得当前时间 video.currentTime</p>
<hr>
<p>展开运算符，展开数组</p>
<p>forEach 就是遍历  加强版的for循环  适合于遍历数组对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// forEach 就是遍历  加强版的for循环  适合于遍历数组对象</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item)  <span class="comment">// 数组元素 red  green pink</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index) <span class="comment">// 索引号</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>filter筛选数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"> <span class="comment">// const newArr = arr.filter(function (item, index) &#123;</span></span><br><span class="line"> <span class="comment">//   // console.log(item)</span></span><br><span class="line"> <span class="comment">//   // console.log(index)</span></span><br><span class="line"> <span class="comment">//   return item &gt;= 20</span></span><br><span class="line"> <span class="comment">// &#125;)</span></span><br><span class="line"> <span class="comment">// 返回的符合条件的新数组</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> newArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">20</span>)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Javascript/">Javascript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%8E%9F%E7%A5%9E1%20(6).jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/weixin.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zhifubao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/05/%E6%96%87%E7%AB%A04/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8E%9F%E7%A5%9E1%20(7).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ajax学习(1)</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/25/%E6%96%87%E7%AB%A02/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8E%9F%E7%A5%9E1%20(4).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WebApi学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/20/%E6%96%87%E7%AB%A01/" title="Javascript基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-20</div><div class="title">Javascript基础</div></div></a></div><div><a href="/2022/10/25/%E6%96%87%E7%AB%A02/" title="WebApi学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8E%9F%E7%A5%9E1%20(4).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">WebApi学习</div></div></a></div><div><a href="/2022/11/15/%E6%96%87%E7%AB%A010/" title="ES6模块化学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/apex%20(19).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">ES6模块化学习</div></div></a></div><div><a href="/2022/11/15/%E6%96%87%E7%AB%A011/" title="webpack学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/apex%20(20).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">webpack学习</div></div></a></div><div><a href="/2022/11/15/%E6%96%87%E7%AB%A013/" title="Vuex学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/apex%20(7).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">Vuex学习</div></div></a></div><div><a href="/2022/12/15/%E6%96%87%E7%AB%A015/" title="Vue3学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/apex%20(14).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-15</div><div class="title">Vue3学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%80%E5%A4%A9"><span class="toc-text">JavaScript 高级第一天</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.1 局部作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.1.1 函数作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.1.2 块作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1.2 全局作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">1.3 作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">1.4 JS垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-GC"><span class="toc-text">1.4.1 垃圾回收机制 GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E5%86%85%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.4.2 内存的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%97%AD%E5%8C%85"><span class="toc-text">1.5 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">1.6 变量提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-text">2.函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">2.1 函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">2.2 函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">2.2.1 动态参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0-%E2%80%A6"><span class="toc-text">2.2.2 剩余参数 …</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2.2.3 展开运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-%E9%87%8D%E8%A6%81"><span class="toc-text">2.3 箭头函数(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.3.1 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">2.3.2 箭头函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this"><span class="toc-text">2.3.3 箭头函数this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">3.解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-text">3.1 数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-text">3.2 对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">3.2.1 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E7%BB%99%E6%96%B0%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E8%B5%8B%E5%80%BC"><span class="toc-text">3.2.2 给新的变量名赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-text">3.2.3 数组对象解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E5%A4%9A%E7%BA%A7%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-text">3.2.4 多级对象解构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-JS%E5%89%8D%E9%9D%A2%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%E6%83%85%E5%86%B5"><span class="toc-text">3.3 JS前面必须加分号情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84-forEach-%E6%96%B9%E6%B3%95-%E9%87%8D%E7%82%B9"><span class="toc-text">3.4 遍历数组 forEach 方法(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0-%E6%B8%B2%E6%9F%93%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">案例练习-渲染商品列表案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E4%BB%B7%E6%A0%BC%E7%AD%9B%E9%80%89"><span class="toc-text">4.综合案例-商品列表价格筛选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AD%9B%E9%80%89%E6%95%B0%E7%BB%84-filter-%E6%96%B9%E6%B3%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">4.1 筛选数组 filter 方法（重点）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%BA%8C%E5%A4%A9"><span class="toc-text">JavaScript 高级第二天</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.深入对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">1.1 创建对象三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%88%A9%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1.1 利用对象字面量创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%88%A9%E7%94%A8new-Object%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1.2 利用new Object创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1.3 利用构造函数创建对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1.2 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98-amp-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">1.3 实例成员&amp;静态成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.内置构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Object"><span class="toc-text">2.1 Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Array"><span class="toc-text">2.2 Array</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0-%E5%91%98%E5%B7%A5%E6%B6%A8%E8%96%AA%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC"><span class="toc-text">案例练习-员工涨薪计算成本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-String"><span class="toc-text">2.3 String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Number"><span class="toc-text">2.4 Number</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%AB%98%E7%BA%A7%E7%AC%AC%E4%B8%89%E5%A4%A9"><span class="toc-text">JavaScript 高级第三天</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">1.编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">1.1 面向过程编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88oop%EF%BC%89"><span class="toc-text">1.2 面向对象编程（oop）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B"><span class="toc-text">3.原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E5%9E%8B"><span class="toc-text">3.1 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-constructor-%E5%B1%9E%E6%80%A7"><span class="toc-text">3.2 constructor 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-text">3.3 对象原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-text">3.4 原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">3.5 原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E2%80%93%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85"><span class="toc-text">4.综合案例–消息提示对象封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%AB%98%E7%BA%A7%E7%AC%AC%E5%9B%9B%E5%A4%A9"><span class="toc-text">JavaScript 高级第四天</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.1 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.2 深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">2.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-throw-%E6%8A%9B%E5%BC%82%E5%B8%B8"><span class="toc-text">2.1 throw 抛异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-try-x2F-catch-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">2.2 try &#x2F; catch 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-debugger"><span class="toc-text">2.3 debugger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86this"><span class="toc-text">3.处理this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-this-%E6%8C%87%E5%90%91"><span class="toc-text">3.1 this 指向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91"><span class="toc-text">3.1.1 普通函数this指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91"><span class="toc-text">3.1.2 箭头函数this指向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%94%B9%E5%8F%98-this"><span class="toc-text">3.2 改变 this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-call"><span class="toc-text">3.2.1 call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-apply"><span class="toc-text">3.2.2 apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-bind"><span class="toc-text">3.2.3 bind()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">4.性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%98%B2%E6%8A%96"><span class="toc-text">4.1 防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%8A%82%E6%B5%81"><span class="toc-text">4.2 节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%80%BB%E7%BB%93"><span class="toc-text">4.3 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%BD%95%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E4%BD%8D%E7%BD%AE"><span class="toc-text">5.综合案例-页面打开，可以记录上一次的视频播放位置</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 盖世英雄昊轩</div><div class="footer_custom_text">追风赶月莫停留，平芜尽处是春山</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/11/15/文章6/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/原神1 (2).png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-15</span><a class="blog-slider__title" href="2022/11/15/文章6/" alt="">Git学习</a><div class="blog-slider__text">Git学习笔记</div><a class="blog-slider__button" href="2022/11/15/文章6/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/11/10/文章5/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/原神1 (2).jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-10</span><a class="blog-slider__title" href="2022/11/10/文章5/" alt="">Ajax学习(2)</a><div class="blog-slider__text">Ajax学习笔记(2)</div><a class="blog-slider__button" href="2022/11/10/文章5/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/11/05/文章4/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/原神1 (7).jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-05</span><a class="blog-slider__title" href="2022/11/05/文章4/" alt="">Ajax学习(1)</a><div class="blog-slider__text">Ajax学习笔记(1)</div><a class="blog-slider__button" href="2022/11/05/文章4/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/10/30/文章3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/原神1 (6).jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-30</span><a class="blog-slider__title" href="2022/10/30/文章3/" alt="">JavaScript高级学习</a><div class="blog-slider__text">JavaScript高级学习笔记</div><a class="blog-slider__button" href="2022/10/30/文章3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/10/25/文章2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/原神1 (4).jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-25</span><a class="blog-slider__title" href="2022/10/25/文章2/" alt="">WebApi学习</a><div class="blog-slider__text">WebApi学习笔记</div><a class="blog-slider__button" href="2022/10/25/文章2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/10/20/文章1/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-20</span><a class="blog-slider__title" href="2022/10/20/文章1/" alt="">Javascript基础</a><div class="blog-slider__text">Javascript基础部分学习笔记</div><a class="blog-slider__button" href="2022/10/20/文章1/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '617592b08dd8441596e568c2eacf37ee';
  var gaud_map_key = '3edcfbc7347ae1c724afe8844d75bf7b';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>